# Rust 基本語法與數據類型
## 1. 變數綁定：`let`、`let mut`、`const`

### `let`（不可變，預設）

```rust
let x = 42;          // 型別由編譯器推導：i32
// x = 7;            // ❌ 編譯錯誤：不可變
```

### `let mut`（可變）

```rust
let mut y = 1;
y = 2;               // ✅ 允許重新賦值（同型別）
```

### `const`（編譯期常數）

```rust
const MAX_POINTS: u32 = 100_000;
```

- **必須**有型別註解。
- 只能使用**編譯期可求值**的表達式。
- 可定義於任意作用域（含模組頂層、全域）。
- 與 `let` 不同，`const` **不是**變數綁定，它在語義上是常數值。

> 補充：`static` 是具有固定記憶體位置（靜態存儲期）的全域變數；常見情境不需用到，且可變 `static mut` 不安全。

---

## 2. Shadowing（遮蔽）

**定義**：使用相同名稱再次 `let` 綁定一個新變數，新的綁定在其作用域內**遮蔽**舊的綁定。

```rust
let x = " 123 ";
let x = x.trim();        // &str
let x: i32 = x.parse().unwrap(); // 轉成 i32（型別可變更）
println!("{x}");         // 123
```

對比 `let mut`：

- `let mut`：改變**同一個**變數的值，**型別不可變**。
- shadowing：產生**新的**綁定，可**改變型別**與可變性，且作用域結束後回到外層綁定。

常見用法：逐步轉換資料、控制可變性範圍、避免引入多個新名稱。

---

## 3. 型別推導與註解

- Rust 會盡可能推導型別：`let n = 0; // i32`
- 當推導不明時需註解：

```rust
let n: i64 = 0;
let bytes: Vec<u8> = vec![1, 2, 3];
```

- 字面量後綴輔助推導：`42u8`、`3.14f32`、`0xffu16`。

---

## 4. 標量類型（Scalar Types）

### 4.1 整數（signed `i*`、unsigned `u*`）

- 位寬：`8, 16, 32, 64, 128, size`（如 `i32`、`u64`、`isize`、`usize`）。
- `isize/usize`：與平台位元數對齊（指標大小）。
- 邊界溢出：預設 `release` 會**環繞（two’s complement wrap）**，`debug` 會 panic；可用 `u32::checked_add` 等安全 API。

### 4.2 浮點（`f32`、`f64`）

- 預設為 `f64`。注意不可比較 NaN：`assert!(f64::NAN != f64::NAN)`。

### 4.3 布林（`bool`）

```rust
let b: bool = true;
```

### 4.4 字元（`char`）

- Unicode scalar value（4 位元組），非單一位元組。

```rust
let ch: char = '我';
```

---

## 5. 複合類型（Compound Types）

### 5.1 元組（`(T1, T2, ...)`）

```rust
let tup: (i32, &str, char) = (7, "hi", 'x');
let (a, b, c) = tup;         // 解構
let first = tup.0;           // 以索引存取
```

### 5.2 陣列（`[T; N]`）與切片（`&[T]`）

```rust
let arr: [u8; 3] = [1, 2, 3];
let arr2 = [1; 3];           // 重複 3 次 3 → [1, 1, 1]
let slice: &[u8] = &arr[..]; // 共享視圖，不擁有資料
```

- **陣列長度是型別的一部分**：`[u8; 3]` 與 `[u8; 4]` 不同型別。
- 切片是動態長度的**借用**視圖。

### 5.3 字串類型：`&str` vs `String`

```rust
let s1: &str = "字面量";           // 指向靜態區域的不可變切片
let mut s2: String = String::from("Hello");
s2.push_str(", world");            // 擁有可變的堆上緩衝區
let s3: &str = &s2;                // &String 可隱式轉為 &str
```

- `String` 擁有所有權、可增長；`&str` 為借用的字串切片。
- 常用轉換：`s2.as_str()`、`String::from(s1)`、`s1.to_string()`。

---

## 6. 常見範式與易錯點

- `const` 一定要型別註解，且值必須是編譯期常量。
- `let mut` 只讓**變數綁定**可變，不保證內部資料結構也可變（例如 `let mut v = Rc::new(1);` 仍不可直接改 `Rc` 內部）。
- Shadowing 與重新賦值不同：shadowing 允許**換型別**，賦值不行。
- 陣列越界會在執行期 panic；切片邊界檢查是安全機制的一部分。
- `char` 是 Unicode scalar，不等於「一個 UTF‑8 位元組」。中文、多表情字元都能放進 `char`。

---

## 7. 綜合範例

```rust
fn main() {
    // 不可變與可變
    let rate = 1.5f64;
    let mut count = 0u32;
    count += 1;

    // const
    const BUF: usize = 1024;
    let buf = [0u8; BUF];

    // shadowing：逐步轉換
    let input = " 42 ";
    let input = input.trim();        // &str
    let input: i32 = input.parse().unwrap();

    // 元組、陣列、切片、字串
    let point: (i32, i32) = (3, 4);
    let arr = [10, 20, 30];
    let view: &[i32] = &arr[1..];    // [20, 30]

    let mut s = String::from("Rust");
    s.push('!');
    let borrowed: &str = &s;

    println!("{rate}, {count}, {BUF}, {input}, ({}, {}), {:?}, {}", 
             point.0, point.1, view, borrowed);
}
```

---

### 速查表（簡版） 

| 主題      | 重點                                             |
| --------- | ------------------------------------------------ |
| `let`     | 不可變（預設）；型別多依推導                     |
| `let mut` | 允許重新賦值；**型別不可變**                     |
| `const`   | 必須型別註解；編譯期常量；可全域                 |
| shadowing | 新綁定遮蔽舊綁定；可改**型別**與可變性           |
| 整數      | `i*`/`u*`，`isize/usize` 與平台位元數對齊        |
| 浮點      | `f32`/`f64`，預設 `f64`                          |
| 布林      | `bool`                                           |
| 字元      | `char`（Unicode scalar value）                   |
| 元組      | 定長、可異質；支援解構、索引                     |
| 陣列/切片 | `[T; N]` 長度屬型別；`&[T]` 為借用視圖           |
| 字串      | `String`（擁有、可變） vs `&str`（借用、不可變） |











